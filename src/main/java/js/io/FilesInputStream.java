package js.io;

import java.io.BufferedOutputStream;
import java.io.Closeable;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Iterator;
import java.util.jar.Attributes;
import java.util.jar.Manifest;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

import js.converter.ConverterRegistry;
import js.util.Files;

/**
 * Files archive input stream. This class works together with {@link FilesOutputStream} to transfer files archives. A files
 * archive is a hierarchical files collections bundled with meta data. Archive is compressed using ZIP lossless data compression
 * and meta is carried by a standard Java JAR Manifest. This class gets a stream for files archive, created by files output
 * stream, and extract meta data and files hierarchy. It provides an iterator for files from archive and an utility method to
 * copy file to target system, see {@link #copy(File)}.
 * 
 * <p>
 * Common use case is with URL connection and Servlet HTTP request but is not limited to this scenario. Input stream for this
 * class could be a file archive stored on disk, but file content should be generated by files output stream. Both output and
 * input streams are processed on the fly.
 * 
 * <pre>
 * FilesOutputStream outputFiles = new FilesOutputStream(connection.getOutputStream());
 * outputFiles.putMeta(&quot;Base-Directory&quot;, baseDir);
 * outputFiles.addFiles(new File(&quot;source-directory&quot;));
 * outputFiles.close();
 * </pre>
 * 
 * <pre>
 * FilesInputStream inputFiles = new FilesInputStream(httpRequest.getInputStream());
 * File baseDir = inputFiles.getMeta(&quot;Base-Directory&quot;, File.class);
 * for (File file : inputFiles) {
 * 	File targetFile = new File(targetDir, file.getPath());
 * 	files.copy(targetFile);
 * }
 * inputFiles.close();
 * </pre>
 * 
 * <p>
 * Manifest is mandatory even if no meta data is present and is always the first entry in archive. There is a single predefined
 * attribute, the implementation version but application level meta data is supported. Files output stream can put arbitrary
 * meta data using {@link FilesOutputStream#putMeta(String, Object)}. On receive side, this files archive input stream can
 * retrieve application meta data uing {@link #getMeta(String)} and related methods.
 * 
 * @author Iulian Rotaru
 */
public class FilesInputStream extends InputStream implements Iterable<File>, Closeable {
	/** Implementation version. */
	private static final String VERSION = "1.0";

	/** Flag true if file separator is Unix like, that is, forward slash. */
	private static final boolean UNIX_PATH = File.separatorChar == '/';

	/** The size of the buffer used for internal bytes processing. */
	private static final int BUFFER_SIZE = 4 * 1024;

	/** Files archive ZIP extractor. */
	private ZipInputStream filesArchive;

	/**
	 * Archive manifest contains a single predefined attribute, namely implementation version. Application meta data can be
	 * retrieved using {@link #getMeta(String)} and related methods.
	 */
	private Manifest manifest;

	/** Files archive iterator. */
	private FilesIterator filesIterator;

	/**
	 * Create files input reader for given files archive and extract manifest. Files archive data should be generated by
	 * {@link FilesOutputStream}.
	 * 
	 * @param filesArchive input stream for a files archive.
	 * @throws IOException if files archive read fails.
	 * @throws InvalidFilesArchiveException if manifest processing fails.
	 */
	public FilesInputStream(InputStream filesArchive) throws IOException {
		this(filesArchive instanceof ZipInputStream ? (ZipInputStream) filesArchive : new ZipInputStream(filesArchive));
	}

	/**
	 * Create files input reader for given files archive and extract manifest. Files archive data should be generated by
	 * {@link FilesOutputStream}.
	 * 
	 * @param filesArchive input stream for a files archive.
	 * @throws IOException if files archive read fails.
	 * @throws InvalidFilesArchiveException if manifest processing fails.
	 */
	public FilesInputStream(ZipInputStream filesArchive) throws IOException {
		this.filesArchive = filesArchive;

		// by convention files archive first entry is the manifest
		ZipEntry entry = this.filesArchive.getNextEntry();
		if (entry == null) {
			throw new InvalidFilesArchiveException("Missing manifest.");
		}

		try {
			this.manifest = new Manifest(this.filesArchive);
			Attributes attributes = manifest.getMainAttributes();
			String version = attributes.getValue(Attributes.Name.MANIFEST_VERSION);
			if (!VERSION.equals(version)) {
				throw new InvalidFilesArchiveException("Bad manifest version |%s|.", version);
			}
		} finally {
			this.filesArchive.closeEntry();
		}

		this.filesIterator = new FilesIterator();
	}

	/**
	 * Read next byte from files archive.
	 * 
	 * @return next byte or -1 if end of archive detected.
	 */
	@Override
	public int read() throws IOException {
		return filesArchive.read();
	}

	/**
	 * Get files archive iterator.
	 * 
	 * @return files archive iterator.
	 */
	@Override
	public Iterator<File> iterator() {
		return filesIterator;
	}

	/**
	 * Close input stream on files archive.
	 */
	@Override
	public void close() throws IOException {
		filesArchive.close();
	}

	/**
	 * Get string value from files archive meta data. Meta data was added into archive by
	 * {@link FilesOutputStream#putMeta(String, Object)}.
	 * 
	 * @param key meta data key.
	 * @return meta data value.
	 * @throws InvalidFilesArchiveException if requested meta data key does not exists.
	 */
	public String getMeta(String key) {
		String value = manifest.getMainAttributes().getValue(key);
		if (value == null) {
			throw new InvalidFilesArchiveException("Missing |%s| attribute from manifest.", key);
		}
		return value;
	}

	/**
	 * Get string value from files archive meta data or default value if requested key does not exist.
	 * 
	 * @param key meta data key,
	 * @param defaultValue default value returned if meta data key not found.
	 * @return meta data value or default value.
	 */
	public String getMeta(String key, String defaultValue) {
		String value = manifest.getMainAttributes().getValue(key);
		return value == null ? defaultValue : value;
	}

	/**
	 * Get files archive meta data converted to requested type.
	 * 
	 * @param key meta data key,
	 * @param type type to convert meta data value to.
	 * @param <T> meta data type.
	 * @return meta data value converted to type.
	 * @throws InvalidFilesArchiveException if requested meta data key does not exists.
	 */
	public <T> T getMeta(String key, Class<T> type) {
		return ConverterRegistry.getConverter().asObject(getMeta(key), type);
	}

	/**
	 * Get files archive meta data converted to requested type or default value if meta data key is missing.
	 * 
	 * @param key meta data key,
	 * @param type type to convert meta data value to,
	 * @param defaultValue default value returned if key not found.
	 * @param <T> meta data type.
	 * @return meta data value converted to type or default value.
	 */
	public <T> T getMeta(String key, Class<T> type, T defaultValue) {
		String value = manifest.getMainAttributes().getValue(key);
		return value == null ? defaultValue : ConverterRegistry.getConverter().asObject(value, type);
	}

	/**
	 * Utility method that copy current ZIP entry to output file. This method is designed to work in conjunction with
	 * {@link FilesIterator} that takes care to update current ZIP entry. Usage pattern is in sample code; trying to use it in
	 * different contexts has not predictable results.
	 * 
	 * <pre>
	 * for (File file : files) {
	 * 	File targetFile = new File(targetDir, file.getPath());
	 * 	files.copy(targetFile);
	 * }
	 * </pre>
	 * 
	 * Files input stream - <code>files</code> is iterated using for each loop. For every source <code>file</code> create
	 * related <code>targetFile</code> and enact files input stream to self copy its current entry to target file. Note that
	 * this method ensure target file parent directories are created. Also this method works in overwrite mode, that is, if
	 * target file already exist it will be overwritten and old content lost.
	 * <p>
	 * Warning: do not use {@link Files#copy(InputStream, OutputStream)}; it closes both input and output streams and trying to
	 * get ZIP next entry after that will fail with <em>stream closed</em> exception.
	 * 
	 * @param targetFile target file.
	 * @throws IOException if read/write operation fails.
	 */
	public void copy(File targetFile) throws IOException {
		Files.mkdirs(targetFile);
		// file output stream is created in overwrite mode
		OutputStream outputStream = new BufferedOutputStream(new FileOutputStream(targetFile));
		try {
			byte[] buffer = new byte[BUFFER_SIZE];
			for (;;) {
				int bytesRead = this.filesArchive.read(buffer);
				if (bytesRead <= 0) {
					break;
				}
				outputStream.write(buffer, 0, bytesRead);
			}
		} finally {
			Files.close(outputStream);
		}
	}

	/**
	 * Iterator over files archive.
	 * 
	 * @author Iulian Rotaru
	 */
	private class FilesIterator implements Iterator<File> {
		/** Current processing file. */
		private File file;

		/**
		 * Returns true if there are more files on files archive.
		 * 
		 * @return true if there are more files on archive.
		 */
		@Override
		public boolean hasNext() {
			file = null;
			try {
				ZipEntry entry = filesArchive.getNextEntry();
				if (entry == null) {
					return false;
				}
				String path = entry.getName();
				if (UNIX_PATH) {
					path = Files.path2unix(path);
				}
				file = new File(path);
				if (file.isDirectory()) {
					throw new InvalidFilesArchiveException("Target file |%s| is a directory.", file.getAbsolutePath());
				}
				return true;
			} catch (IOException e) {
				throw new InvalidFilesArchiveException("Cannot read next entry: " + e.getMessage());
			}
		}

		/**
		 * Get next file from archive. This method should be called after {@link #hasNext()}.
		 * 
		 * @return current processing file prepared by {@link #hasNext()}.
		 */
		@Override
		public File next() {
			return file;
		}

		/**
		 * File remove from archive not supported.
		 * 
		 * @throws UnsupportedOperationException always since remove is not supported.
		 */
		@Override
		public void remove() {
			throw new UnsupportedOperationException();
		}
	}
}
